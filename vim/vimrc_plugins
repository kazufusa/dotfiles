"-------------------------------------------------------------------------------
" Plugin settings
" using NeoBundle
"-------------------------------------------------------------------------------

" neobundle & vimproc {{{
let s:noplugin = 0
let s:bundle_root = expand('~/.vim/bundle')
let s:neobundle_root = s:bundle_root . '/neobundle.vim/'

if !isdirectory(s:neobundle_root) || v:version < 702
    " NeoBundleが存在しない、もしくはVimのバージョンが古い場合はプラグインを一切
    " 読み込まない
    let s:noplugin = 1
else
    " NeoBundleを'runtimepath'に追加し初期化を行う
    if has('vim_starting')
        execute "set runtimepath+=" . s:neobundle_root
    endif
    call neobundle#rc(s:bundle_root)

    " NeoBundle自身をNeoBundleで管理させる
    NeoBundleFetch 'Shougo/neobundle.vim'

    " 非同期通信を可能にする
    " 'build'が指定されているのでインストール時に自動的に
    " 指定されたコマンドが実行され vimproc がコンパイルされる
    NeoBundle "Shougo/vimproc", {
        \ "build": {
        \   "windows"   : "make -f make_mingw32.mak",
        \   "cygwin"    : "make -f make_cygwin.mak",
        \   "mac"       : "make -f make_mac.mak",
        \   "unix"      : "make -f make_unix.mak",
        \ }}
endif
" }}}

" Shougo/unite {{{
NeoBundleLazy "Shougo/unite.vim", {
      \ "autoload": {
      \   "commands": ["Unite", "UniteWithBufferDir"]
      \ }}
" 未整備
" http://d.hatena.ne.jp/osyo-manga/20130625/1372170654
let g:unite_enable_start_insert=1
let g:unite_source_history_yank_enable =1
let g:unite_source_file_mru_limit = 1000

NeoBundleLazy 'zhaocai/unite-outline', {
    \ 'autoload' : {
    \   'unite_sources' : 'outline'},
    \ }
NeoBundleLazy 'Shougo/neomru.vim', {
    \ 'depends' : 'Shougo/unite.vim',
    \ 'autoload' : {
    \   'unite_sources' : 'file_mru'},
    \ }
nnoremap <silent> <Space>uy :<C-u>Unite history/yank<CR>
nnoremap <silent> <Space>ub :<C-u>Unite buffer -default-action=tabopen<CR>
nnoremap <silent> <Space>uf :<C-u>UniteWithBufferDir -buffer-name=files file -default-action=tabopen<CR>
nnoremap <silent> <Space>ur :<C-u>Unite -buffer-name=register register<CR>
nnoremap <silent> <Space>uo :<C-u>Unite outline<CR>
nnoremap <silent> <Space>uu :<C-u>Unite file_mru buffer -default-action=tabopen<CR>
" }}}

" quickrun {{{
NeoBundleLazy "thinca/vim-quickrun", {
      \ "autoload": {
      \   "mappings": [['nxo', '<Plug>(quickrun)']]
      \ }}
nmap <Leader>r <Plug>(quickrun)
let s:hooks = neobundle#get_hooks("vim-quickrun")
function! s:hooks.on_source(bundle)
    let g:quickrun_config = {
    \   "_" : {
    \       "outputter/buffer/split" : ":botright",
    \       "outputter/buffer/close_on_empty" : 1
    \   },
    \}
    let g:quickrun_config['_']['runner'] = 'vimproc'
    let g:quickrun_config['_']['runner/vimproc/updatetime'] = 100
    " <C-c> で実行を強制終了させる
    nnoremap <expr><silent> <C-c> quickrun#is_running() ? quickrun#sweep_sessions() : "\<C-c>"
endfunction
" }}}

" vimfiler {{{
NeoBundleLazy "Shougo/vimfiler", {
      \ "depends": ["Shougo/unite.vim"],
      \ "autoload": {
      \   "commands": ["VimFilerTab", "VimFiler", "VimFilerExplorer"],
      \   "mappings": ['<Plug>(vimfiler_switch)'],
      \   "explorer": 1,
      \ }}
nnoremap <Leader>e :VimFilerExplorer<CR>
" close vimfiler automatically when there are only vimfiler open
autocmd MyAutoCmd BufEnter * if (winnr('$') == 1 && &filetype ==# 'vimfiler') | q | endif
let s:hooks = neobundle#get_hooks("vimfiler")
function! s:hooks.on_source(bundle)
  let g:vimfiler_as_default_explorer = 1
  let g:vimfiler_enable_auto_cd = 1
  
  " .から始まるファイルおよび.pycで終わるファイルを不可視パターンに
  " 2013-08-14 追記
  let g:vimfiler_ignore_pattern = "\%(^\..*\|\.pyc$\)"

  " vimfiler specific key mappings
  autocmd MyAutoCmd FileType vimfiler call s:vimfiler_settings()
  function! s:vimfiler_settings()
    " ^^ to go up
    nmap <buffer> b <Plug>(vimfiler_switch_to_parent_directory)
    " use R to refresh
    nmap <buffer> R <Plug>(vimfiler_redraw_screen)
    " overwrite C-l
    nmap <buffer> <C-l> <C-w>l
  endfunction
endfunction
" }}}

" colorscheme {{{
NeoBundle 'nanotech/jellybeans.vim'
NeoBundle 'w0ng/vim-hybrid'
NeoBundle 'vim-scripts/twilight'
NeoBundle 'jonathanfilip/vim-lucius'
NeoBundle 'jpo/vim-railscasts-theme'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'vim-scripts/Wombat'
NeoBundle 'tomasr/molokai'
NeoBundle 'vim-scripts/rdark'
syntax enable
" sets for solarized
set background=dark
let g:solarized_termtrans=1
let g:solarized_termcolors=256
"colorscheme solarized
"colorscheme molokai
colorscheme hybrid
" }}}

" neocomlcache {{{
NeoBundleLazy 'Shougo/neocomplcache.vim', {
    \ "autoload": {"insert": 1}}
let s:hooks = neobundle#get_hooks("neocomplcache.vim")
" neocomplete用の設定関数を定義。下記関数はneocompleteロード時に実行される
function! s:hooks.on_source(bundle)
    let g:neocomplcache_enable_at_startup=1
    let g:neocomplcache_auto_completion_start_length=2
    let g:neocomplcache_enable_ignore_case=0
    let g:neocomplcache_enable_smart_case=0
    let g:neocomplcache_enable_camel_case_completion=1
    let g:neocomplcache_enable_underbar_completion=1

    inoremap <expr><S-TAB> pumvisible() ? "\<Up>" : "\<S-TAB>"

    " Plugin key-mappings for snippets.
    imap <C-k> <Plug>(neosnippet_expand_or_jump)
    smap <C-k> <Plug>(neosnippet_expand_or_jump)
    xmap <C-k> <Plug>(neosnippet_expand_target)

    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \: pumvisible() ? "\<C-n>" : "\<TAB>"
    imap <expr><TAB> pumvisible() ?
    \ "\<C-n>" : neosnippet#jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \: "\<TAB>"

"    " For snippet_complete marker.
"    if has('conceal')
"      set conceallevel=2 concealcursor=i
"    endif

"    "<CR>（ENTER）で候補を閉じ改行
"    inoremap <expr><CR> neocomplcache#close_popup() . "\<CR>"
"    "1つ前の補完を取り消す
"    inoremap <expr><C-g> neocomplcache#undo_completion()
"    "<C-h>や<BS>を押したときに確実にポップアップを削除す
"    inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
"    inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
"    "現在選択している候補を確定する
"    inoremap <expr><C-y> neocomplcache#close_popup()
"    "現在選択している候補をキャンセルし、ポップアップを閉じる
"    inoremap <expr><C-e> neocomplcache#cancel_popup()
"    let g:neocomplcache_enable_cursor_hold_i=0
"    let g:neocomplcache_max_list=1000
    " for clang_complete
    let g:neocomplcache_force_overwrite_completefunc=1
    if !exists("g:neocomplcache_force_omni_patterns")
        let g:neocomplcache_force_omni_patterns = {}
    endif
    let g:neocomplcache_force_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|::'
endfunction
" }}}

" clang_complete  {{{
"" let g:clang_snippets=1
NeoBundleLazy "Rip-Rip/clang_complete", {'autoload': {'filetypes': ['cpp']}}
let g:clang_complete_auto=0
let g:clang_auto_select=0
"let g:clang_sort_algo="alpha"
let g:clang_sort_algo="priority"
let g:clang_debug=1
let g:clang_user_options = '-std=c++11'
" exec or library use
if OSTYPE == "Darwin\n"
    let g:clang_use_library=1
    let g:clang_debug=1
    let g:clang_library_path="/opt//local/libexec/llvm-3.4/lib/"
elseif OSTYPE == "Linux\n"
    let g:clang_use_library=1
    let g:clang_debug=1
    let g:clang_library_path="/usr/lib/"
elseif has('win32') || has('win64')
endif
" }}}

" Shougo/neosnippet {{{
"NeoBundle "Shougo/neosnippet-snippets"
NeoBundleLazy "Shougo/neosnippet.vim", {
      \ "depends": ["honza/vim-snippets", "Shougo/neosnippet-snippets"],
      \ "autoload": {
      \   "insert": 1,
      \ }}
let s:hooks = neobundle#get_hooks("neosnippet.vim")
function! s:hooks.on_source(bundle)
    " Plugin key-mappings.
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    smap <C-k>     <Plug>(neosnippet_expand_or_jump)
    xmap <C-k>     <Plug>(neosnippet_expand_target)
    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \: pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    \ "\<Plug>(neosnippet_expand_or_jump)"
    \: "\<TAB>"
    " For snippet_complete marker.
    if has('conceal')
          set conceallevel=2 concealcursor=i
    endif
    " Enable snipMate compatibility feature.
    let g:neosnippet#enable_snipmate_compatibility = 1
    " Tell Neosnippet about the other snippets
    let g:neosnippet#snippets_directory=s:bundle_root . '/vim-snippets/snippets'
endfunction
" }}}

" thinca/vim-template {{{
NeoBundle "thinca/vim-template"
" テンプレート中に含まれる特定文字列を置き換える
autocmd MyAutoCmd User plugin-template-loaded call s:template_keywords()
function! s:template_keywords()
    silent! %s/<+DATE+>/\=strftime('%Y-%m-%d')/g
    silent! %s/<+FILENAME+>/\=expand('%:r')/g
endfunction
" テンプレート中に含まれる'<+CURSOR+>'にカーソルを移動
autocmd MyAutoCmd User plugin-template-loaded
    \   if search('<+CURSOR+>')
    \ |   silent! execute 'normal! "_da>'
    \ | endif
" }}}

" vim-indent-guides {{{
NeoBundle "nathanaelkane/vim-indent-guides"
let g:indent_guides_enable_on_vim_startup = 1
" 自動カラーを無効にする
let g:indent_guides_auto_colors=0
" 奇数インデントのカラー
hi IndentGuidesOdd ctermbg=237
" 偶数インデントのカラー
"autocmd VimEnter,Colorscheme * :hi IndentGuidesEven ctermbg=3
" ハイライト色の変化の幅
let g:indent_guides_color_change_percent = 100
" ガイドの幅
let g:indent_guides_guide_size = 4

"}}}

" sjl/gundo {{{
NeoBundleLazy "sjl/gundo.vim", {
      \ "autoload": {
      \   "commands": ['GundoToggle'],
      \}}
nnoremap <Leader>g :GundoToggle<CR>
" }}}

" vim-ref {{{
"webdict reffering site
NeoBundle 'thinca/vim-ref'
let g:ref_open = 'split'
let g:ref_source_webdict_sites = {
\ 'ej': {
\ 'url': 'http://ejje.weblio.jp/content/%s',
\ },
\ 'th': {
\ 'url': 'http://ejje.weblio.jp/english-thesaurus/content/%s',
\ },
\ 'codic': {
\ 'url': 'http://codic.jp/search?q=%s',
\ },
\ 'wiki': {
\ 'url': 'http://ja.wikipedia.org/wiki/%s',
\ },
\ }

" default site
let g:ref_source_webdict_sites.default = 'ej'

" output filter
function! g:ref_source_webdict_sites.ej.filter(output)
  return join(split(a:output, "\n")[54 :], "\n")
endfunction
function! g:ref_source_webdict_sites.th.filter(output)
  return join(split(a:output, "\n")[47 :], "\n")
endfunction
function! g:ref_source_webdict_sites.wiki.filter(output)
  return join(split(a:output, "\n")[5 :], "\n")
endfunction
function! g:ref_source_webdict_sites.codic.filter(output)
  return join(split(a:output, "\n")[14 :], "\n")
endfunction

nnoremap <Leader>re :<C-u>Ref webdict ej<Space>
nnoremap <Leader>rt :<C-u>Ref webdict th<Space>
nnoremap <Leader>rw :<C-u>Ref webdict wiki<Space>
nnoremap <Leader>rr :<C-u>Ref webdict codic<Space>
nnoremap re :Ref webdict ej <C-R><C-W> <CR>
nnoremap rt :Ref webdict th <C-R><C-W> <CR>
nnoremap rw :Ref webdict wiki <C-R><C-W> <CR>
nnoremap rr :Ref webdict codic <C-R><C-W> <CR>
" }}}

" python PEP8 checker {{{
NeoBundleLazy 'Flake8-vim' , {'autoload': {'filetypes': ['python']}}
NeoBundleLazy 'hynek/vim-python-pep8-indent', {'autoload': {'filetypes': ['python']}}
let s:hooks = neobundle#get_hooks("Flake8-vim")
function! s:hooks.on_source(bundle)
    "保存時に自動でチェック
    let g:PyFlakeOnWrite = 1
    ""解析種別を設定
    let g:PyFlakeCheckers = 'pep8,mccabe,pyflakes'
    "McCabe複雑度の最大値
    let g:PyFlakeDefaultComplexity=10
    ""visualモードでQを押すと自動で修正
    let g:PyFlakeRangeCommand = 'Q'
    "nnoremap <Leader>q :PyFlakeAuto<CR>
    " CWindowsが邪魔いので表示しない
    let g:PyFlakeCWindow = 0
endfunction
" }}}

" over.vim {{{
NeoBundle 'osyo-manga/vim-over'
"over.vimの起動
nnoremap <silent> <Leader>m :OverCommandLine<CR>
" カーソル下の単語をハイライト付きで置換
nnoremap sub :OverCommandLine<CR>%s/<C-r><C-w>//g<Left><Left>
" コピーした文字列をハイライト付きで置換
nnoremap subp y:OverCommandLine<CR>%s!<C-r>=substitute(@0, '!', '\\!', 'g')<CR>!!gI<Left><Left><Left>

 " }}}

" wauto.vim {{{
NeoBundle 'syui/wauto.vim'
let g:auto_write = 1
" }}}

" vim-surround {{{
NeoBundle 'tpope/vim-surround'
" }}}
"
" memolist{{{
NeoBundle 'glidenote/memolist.vim'
let g:memolist_path = "~/Dropbox/memo"
" }}}

" lightline.vim {{{
NeoBundle 'gh:itchyny/lightline.vim.git'
" vim-gitgutter
let g:gitgutter_sign_added = '✚'
let g:gitgutter_sign_modified = '➜'
let g:gitgutter_sign_removed = '✘'

" lightline.vim
let g:lightline = {
        \ 'colorscheme': 'landscape',
        \ 'mode_map': {'c': 'NORMAL'},
        \ 'active': {
        \   'left': [
        \     ['mode'],
        \     ['fugitive', 'gitgutter', 'filename'],
        \   ],
        \   'right': [
        \     ['lineinfo', 'syntastic'],
        \     ['percent'],
        \     ['charcode', 'fileformat', 'fileencoding', 'filetype'],
        \   ]
        \ },
        \ 'component_function': {
        \   'modified': 'MyModified',
        \   'readonly': 'MyReadonly',
        \   'fugitive': 'MyFugitive',
        \   'filename': 'MyFilename',
        \   'fileformat': 'MyFileformat',
        \   'filetype': 'MyFiletype',
        \   'fileencoding': 'MyFileencoding',
        \   'mode': 'MyMode',
        \   'syntastic': 'SyntasticStatuslineFlag',
        \   'charcode': 'MyCharCode',
        \   'gitgutter': 'MyGitGutter',
        \ },
        \ 'separator': {'left': '⮀', 'right': '⮂'},
        \ 'subseparator': {'left': '⮁', 'right': '⮃'}
        \ }

function! MyModified()
  return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
  return &ft !~? 'help\|vimfiler\|gundo' && &ro ? '⭤' : ''
endfunction

function! MyFilename()
    return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
        \ (&ft == 'vimfiler' ? vimfiler#get_status_string() : 
        \  &ft == 'unite' ? unite#get_status_string() : 
        \  &ft == 'vimshell' ? vimshell#get_status_string() :
        \ '' != FilePathSnippet() ? FilePathSnippet() : '[No Name]') .
        \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! FilePathSnippet()
    let path = expand('%:p:h') . "/"
    let length = strlen(expand('%:p:h'))
    return length > 25 ? '..' . path[length - 25: length] : path
endfunction

function! MyFugitive()
  try
    if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
      let _ = fugitive#head()
      return strlen(_) ? '⭠ '._ : ''
    endif
  catch
  endtry
  return ''
endfunction

function! MyFileformat()
  return winwidth('.') > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
  return winwidth('.') > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
  return winwidth('.') > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
  return winwidth('.') > 60 ? lightline#mode() : ''
endfunction

function! MyGitGutter()
  if ! exists('*GitGutterGetHunkSummary')
        \ || ! get(g:, 'gitgutter_enabled', 0)
        \ || winwidth('.') <= 90
    return ''
  endif
  let symbols = [
        \ g:gitgutter_sign_added . ' ',
        \ g:gitgutter_sign_modified . ' ',
        \ g:gitgutter_sign_removed . ' '
        \ ]
  let hunks = GitGutterGetHunkSummary()
  let ret = []
  for i in [0, 1, 2]
    if hunks[i] > 0
      call add(ret, symbols[i] . hunks[i])
    endif
  endfor
  return join(ret, ' ')
endfunction

" https://github.com/Lokaltog/vim-powerline/blob/develop/autoload/Powerline/Functions.vim
function! MyCharCode()
  if winwidth('.') <= 70
    return ''
  endif

  " Get the output of :ascii
  redir => ascii
  silent! ascii
  redir END

  if match(ascii, 'NUL') != -1
    return 'NUL'
  endif

  " Zero pad hex values
  let nrformat = '0x%02x'

  let encoding = (&fenc == '' ? &enc : &fenc)

  if encoding == 'utf-8'
    " Zero pad with 4 zeroes in unicode files
    let nrformat = '0x%04x'
  endif

  " Get the character and the numeric value from the return value of :ascii
  " This matches the two first pieces of the return value, e.g.
  " "<F>  70" => char: 'F', nr: '70'
  let [str, char, nr; rest] = matchlist(ascii, '\v\<(.{-1,})\>\s*([0-9]+)')

  " Format the numeric value
  let nr = printf(nrformat, nr)

  return "'". char ."' ". nr
endfunction
" }}}

" relate to Git {{{
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'airblade/vim-gitgutter'
NeoBundle 'mattn/gist-vim'
NeoBundle 'mattn/webapi-vim'
nnoremap <silent> <Leader>gg :<C-u>GitGutterToggle<CR>
nnoremap <silent> <Leader>gh :<C-u>GitGutterLineHighlightsToggle<CR>
let g:gist_get_multiplefile = 1
" }}}

 " coffeescript{{{
NeoBundleLazy 'kchmck/vim-coffee-script', {
      \ "autoload": {
      \   "filetypes": ["coffee", "COFFEE"],
      \ }}
" }}}

" jinja2 syntax {{{
NeoBundleLazy 'Glench/Vim-Jinja2-Syntax', {
    \ 'autoload': {
    \   'filetypes' : ["jinja"],
    \   'filename_patterns' : ['.*\.jinja.*'],
    \ }}
" }}}

" jade syntax {{{
NeoBundleLazy 'digitaltoad/vim-jade', {
    \ 'autoload': {
    \   'filetypes' : ["jade"],
    \   'filename_patterns' : ['.*\.jade'],
    \ }}
" }}}

" qiita{{{
NeoBundle 'mattn/qiita-vim'
" }}}

" vim-rails{{{
NeoBundle 'tpope/vim-rails'
" }}}

" html5 syntax {{{
NeoBundleLazy 'othree/html5.vim', {
    \ 'autoload': {
    \   'filetypes' : ["jade", "html", "eruby"],
    \ }}
" }}}

" haml {{{
NeoBundleLazy "tpope/vim-haml", {
    \ 'autoload': {
    \   'filetypes' : ["haml"],
    \ }}
" }}}

" text object {{{
" textobj のベース
NeoBundle "kana/vim-textobj-user"

" バッファ全体
" ae, ie
NeoBundle "kana/vim-textobj-entire"

" カーソル行
" al, il
NeoBundle "kana/vim-textobj-line"

" 関数内
" af, if
NeoBundle "kana/vim-textobj-function"

" シンタックス
" ay, iy
NeoBundle "kana/vim-textobj-syntax"


" 「foo」 or 【bar】など
" ajb, ijb
NeoBundle "kana/vim-textobj-jabraces"

" 最後に検索されたパターン
" a/, i/
NeoBundle "kana/vim-textobj-lastpat"


" カーソル位置と同じインデント
" al, il
NeoBundle "kana/vim-textobj-indent"

" fold
" az, iz
NeoBundle "kana/vim-textobj-fold"

" diff(1)
" adf, idf
NeoBundle "kana/vim-textobj-syntax"

" 日付と時刻
" ada, ida
NeoBundle "kana/vim-textobj-datetime"

" アンダースコアの間
" 
NeoBundle "kana/vim-textobj-syntax"

" django_template
" adb, idb
NeoBundle "kana/vim-textobj-django-template"

" 任意の区切り文字
" af, if
NeoBundle "thinca/vim-textobj-between"

" コメント
" ac, ic
NeoBundle "thinca/vim-textobj-comment"

" JavaScript の関数内
" af, if
NeoBundle "thinca/vim-textobj-function-javascript"

" Perl の関数内
" af, if
NeoBundle "thinca/vim-textobj-function-perl"

" 直前に変更またはヤンクされたテキスト
" ip
NeoBundle "gilligan/textobj-lastpaste"

" ASCII文字とマルチバイト文字の境界を区切り
" am, im
NeoBundle "deton/textobj-mbboundary.vim"

" XML の属性
" axa, ixa
NeoBundle "akiyan/vim-textobj-xml-attribute"

" phpタグに囲まれた部分
" aP, iP
NeoBundle "akiyan/vim-textobj-php"


" 連続したスペース
" aS, iS
NeoBundle "saihoooooooo/vim-textobj-space"

" URL
" au, iu
NeoBundle "mattn/vim-textobj-url"

" snake_case 上の word
" a,w, i,w
NeoBundle "h1mesuke/textobj-wiw"

" テキストオブジェクトとして最後に挿入された範囲
" au, iu
NeoBundle "rhysd/vim-textobj-lastinserted"


" 行継続を用いている行
" av, iv
NeoBundle "rhysd/vim-textobj-continuous-line"

" Ruby のブロック
" arr, brr
NeoBundle "rhysd/vim-textobj-ruby"

" x() や x<> など
" axb, ixb
NeoBundle "https://bitbucket.org/anyakichi/vim-textobj-xbrackets"

" 任意の2つの motion の間
" am, im
NeoBundle "hchbaw/textobj-motionmotion.vim"

" Perl や Ruby の正規表現
" aq, iq
NeoBundle "deris/vim-textobj-enclosedsyntax"

" 行の先頭の word
" ah, ih
NeoBundle "deris/vim-textobj-headwordofline"

" LaTeX
" ae, ie
NeoBundle "rbonvall/vim-textobj-latex"

" 関数の引数
" a, i,
NeoBundle "sgur/vim-textobj-parameter"

" 前後のスペースを取り除いたカーソル行
" ac, ic
NeoBundle "mattn/vim-textobj-cell"

" 別の filetype のコンテキスト
" icx
NeoBundle "osyo-manga/vim-textobj-context"

" 任意の複数の括弧のいずれか
" asb, isb
NeoBundle "osyo-manga/vim-textobj-multiblock"

" インデントの空白行
" ao, io
NeoBundle "glts/vim-textobj-indblock"

" ダッシュ記号の間
" a-, i-
NeoBundle "RyanMcG/vim-textobj-dash"

" Python
" af, if
NeoBundle "bps/vim-textobj-python"

" #ifdef
" a#, i#
NeoBundle "anyakichi/vim-textobj-ifdef"

" HTML
" ahf, ihf
NeoBundle "mjbrownie/html-textobjects"

" ハッシュの key と value
" dak, dik,  dav, div
NeoBundle "vimtaku/vim-textobj-keyvalue"
" }}}

" go{{{
NeoBundleLazy 'Blackrush/vim-gocode', {
    \ 'autoload': {
    \   'filetypes' : ["go"],
    \ }}
" }}}

" SCSS&CSS {{{
NeoBundleLazy 'JulesWang/css.vim', {
    \ 'autoload': {
    \   'filetypes' : ["css", "scss"],
    \ }}
NeoBundleLazy 'cakebaker/scss-syntax.vim', {
    \ 'autoload': {
    \   'filetypes' : ["css", "scss"],
    \ }}
" }}}

" IM_control {{{
NeoBundle 'fuenor/im_control.vim'
" fcitx

" 「日本語入力固定モード」の動作設定
let IM_CtrlMode = 6
" 「日本語入力固定モード」切替キー
inoremap <silent> <C-j> <C-r>=IMState('FixMode')<CR>

"<ESC>押下後のIM切替開始までの反応が遅い場合はttimeoutlenを短く設定してみてください(ミリ秒)
set timeout timeoutlen=3000 ttimeoutlen=100
" }}}

" for html edit{{{
NeoBundle 'mattn/emmet-vim'
"NeoBundleLazy 'mattn/emmet-vim', {
"    \ 'autoload': {
"    \   'filetypes' : ["html"],
"    \ }}
let g:user_emmet_settings = {
    \   'lang' : 'ja'
    \ }
"let g:user_emmet_leader_key='<Space>e'
" }}}

" auto check
NeoBundleCheck

" ファイルタイププラグインおよびインデントを有効化
" これはNeoBundleによる処理が終了したあとに呼ばなければならない
filetype plugin indent on
